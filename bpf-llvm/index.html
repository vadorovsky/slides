<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BPF LLVM</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown>
        <textarea data-template>
                    ## The BPF target in LLVM
                    <img src="/images/ebpf.png" />
                    ---
                    ## About me
                    * Michal Rostecki
                    * **vadorovsky** @ Github, Discord, Mastodon etc.
                    * Software Engineer @ [**Light Protocol**](https://lightprotocol.com) (ZK on Solana)
                    * [**Aya**](https://aya-rs.dev) maintainer (BPF library for Rust)
                    * Interests: Linux kernel, Rust, ZK cryptography
                    ---
                    ## BPF
                    * "Berkeley Packet Filter"
                    * ...but that's not what it is, really.
                    * It's a virtual machine for running minimal, sandboxed programs.
                    * Restricted environment (instruction limit, verifier).
                    * Rules: execute fast, don't sleep*, don't allocate too much
                      memory.
                    ---
                    ## Use cases
                    * **Linux kernel** - BPF originates from there
                      * Network filtering
                      * Tracing and profiling
                      * Security policies
                    * **Solana**
                      * Smart contracts
                    * [**IoT / microcontrollers**](https://ieeexplore.ieee.org/abstract/document/9293081)
                    ---
                    ## Projects
                    * **Cilium** - Container Network Interface for Kubernetes.
                    * **Falco** - Security alert engine.
                    * Pretty much every Solana project. Orca, Mango, Audius,
                      Metaplex, Light Protocol etc.
                    * **Good stuff from Deepfence coming soon!** Security, but
                      with focus on enforcement.
                    ---
                    ## BPF and LLVM
                    * First and main compiler providing BPF support.
                    * BPF has a backend in LLVM.
                    * Supported by Clang (C) and Rust.
                    ---
                    ## Enabling BPF backend
                    ```
                    -DLLVM_TARGETS_TO_BUILD="host;BPF"
                    ```
                    e.g.
                    ```
                    CC=clang CXX=clang++ cmake -DCMAKE_BUILD_TYPE=Debug \
                      -DLLVM_PARALLEL_LINK_JOBS=1 -DLLVM_BUILD_LLVM_DYLIB=1 \
                      -DLLVM_ENABLE_LLD=1 -DLLVM_ENABLE_PROJECTS="clang" \
                      -DLLVM_TARGETS_TO_BUILD="host;BPF"
                    ```
                    ---
                    ## Registers
                    * **R0** - return value from functions, exit values for programs.
                    * **R1** - **R5** - function arguments.
                    * **R6** - **R9** - callee saved registers that function calls will preserve.
                    * **R10** - read-only frame pointer to access stack.
                    **R0** - **R5**: scratch registers, programs need to spill them if necessary
                    across calls.
                    ---
                    ## Basic instruction encoding
                    | 32 bits (MSB) | 16 bits | 4 bits | 4 bits | 8 bits (LSB) |
                    | --- | --- | --- | --- | --- |
                    | Integer Immediate Value | Offset | Source register | Destination register | Opcode |
                    ---
                    ## Wide instruction encoding
                    ---
                    ## Arithmetic instructions
                    | Code | Description |
                    | --- | --- |
                    | BPF_ADD | dst += src |
                    | BPF_SUB | dst -= src |
                    | BPF_MUL | dst *= src |
                    | BPF_DIV | dst = (src != 0) ? (dst / src) : 0 |
                    | BPF_OR | dst |= src |
                    | BPF_AND | dst &= src |
                    ---
                    ## Byte swap instructions
                    | Code | Description |
                    | --- | --- |
                    | BPF_TO_LE | host byte order -> little endian |
                    | BPF_TO_BE | host byte order -> big endian |
                    ---
                    ## Jump instructions
                    | Code | Description |
                    | --- | --- |
                    | BPF_CALL | function call |
                    | BPF_EXIT | program return |
                    ---
                    ## Load and store instructions
                    ---
                    ## Atomic operations
                    ---
                    ## Example (C code)
                    ```c
                    #include <linux/bpf.h>
                    #include <bpf/bpf_helpers.h>

                    SEC("xdp")
                    int  xdp_prog_simple(struct xdp_md *ctx)
                    {
                    	return XDP_PASS;
                    }

                    char _license[] SEC("license") = "GPL";
                    ```
                    ---
                    ## Building (clang)
                    ```
                    clang -O2 -target bpf -c -g xdp.c -o xdp.o
                    ```
                    ---
                    ## llvm-readelf
                    ```
                    $ llvm-readelf -S xdp.o
                    // TODO
                    ```
                    ---
                    ## llvm-objdump
                    ```
                    $ llvm-objdump -S xdp.o
                    // TODO
                    ```
                    ---
                    ## Emitting IR
                    ```
                    clang -O2 -target bpf -c -g xdp.c -S -emit-llvm -o xdp.ll
                    ```
                    ---
                    ## IR
                    ```
                    // TODO
                    ```
                    ---
                    ## Example (Rust code)
                    ```rust
                    #![no_std]
                    #![no_main]
                                      
                    use aya_bpf::{bindings::xdp_action, cty::c_long, macros::xdp, programs::XdpContext};

                    #[xdp(name = "xdp_hello")]
                    pub fn xdp_hello(ctx: XdpContext) -> u32 {
                        match try_xdp_hello(ctx) {
                            Ok(ret) => ret,
                            Err(_) => xdp_action::XDP_ABORTED,
                        }
                    }

                    fn try_xdp_hello(ctx: XdpContext) -> Result<u32, c_long> {
                        Ok(xdp_action::XDP_PASS)
                    }
                    ```
                    ---
                    ## Building (Rust)
                    ```
                    cargo +nightly build --target=bpfel-unknown-none \
                      -Z build-std=core
                    ```
                    ---
                    ## llvm-readelf
                    ```
                    $ llvm-readelf -S target/bpfel-unknown-none/debug/xdp-hello
                    // TODO
                    ```
                    ---
                    ## llvm-objdump
                    ```
                    $ llvm-objdump -S target/bpfel-unknown-none/debug/xdp-hello
                    [...]
                    Disassembly of section xdp/xdp_hello:

                    0000000000000000 <xdp_hello>:
                           0:   bf 16 00 00 00 00 00 00 r6 = r1
                           1:   b7 07 00 00 00 00 00 00 r7 = 0
                           2:   63 7a fc ff 00 00 00 00 *(u32 *)(r10 - 4) = r7
                           3:   bf a2 00 00 00 00 00 00 r2 = r10
                    :
                         245:   18 03 00 00 ff ff ff ff 00 00 00 00 00 00 00 00 r3 = 4294967295 ll
                         247:   bf 04 00 00 00 00 00 00 r4 = r0
                         248:   b7 05 00 00 aa 00 00 00 r5 = 170
                         249:   85 00 00 00 19 00 00 00 call 25
                    ```
                    ---
                    ## Emitting IR
                    ```
                    cargo +nightly rustc -- --target=bpfel-unknown-none \
                      -Z build-std=core --emit=llvm-ir
                    ```
                    ---
                    ## IR
                    ```
                    // TODO
                    ```
                    ---
                    ## Linking
                    * BPF target is **not** supported by lld.
                    * Instead, BPF has its own linkers:
                      * **bpftool-link** - creted by libbpf community
                      * **bpf-linker** - for Rust, created by Aya community
                    * Only static linking.
                    ---
                    ## lld
                    * There is a patch for lld to support BPF target, but it's
                      not accepted.
                      * https://reviews.llvm.org/D101336
                    ---
                    ## Verifier
                    * (So far) only in Linux kernel (Solana, rBPF and other user space
                      implementations don't have it).
                    * Ensuring safe memory access - kinda, like, making C Rusty ( ͡° ͜ʖ ͡°).
                    * DAG check preventing unbound loops.
                    * Descending all possible instruction paths, observing the
                      change of registers and stack.
                    ---
                    ## How verifier works
                    * TODO
                    ---
                    ## Verifier errors
                    * `unreachable insn`
                    * `!read_ok`
                    * `invalid stack`
                    * `invalid indirect read from stack`
                    * `invalid mem access`
                    * `offset is outside of the packet`
                    ---
                    ## BPF Type Format (BTF)
                    * Debug info format for BPF, way more lightweight than DWARF.
                    * Used for offsets across Linux kernel versions.
                    * Used for stack traces in BPF verifier.
                    * But there is no debugger (yet).
                    ---
                    ## Example: C code
                    ```c
                    struct foo {
                    	__u32 a;
                    	__u64 b;
                    };
                    ```
                    ---
                    ## Example: LLVM debug info
                    ```
                    !49 = distinct !DICompositeType(tag: DW_TAG_structure_type,
                      name: "foo", file: !3, line: 21, size: 128, elements: !50)
                    !50 = !{!51, !54}
                    !51 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !49,
                      file: !3, line: 22, baseType: !52, size: 32)
                    !52 = !DIDerivedType(tag: DW_TAG_typedef, name: "__u32",
                      file: !53, line: 27, baseType: !12)
                    !54 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !49,
                      file: !3, line: 23, baseType: !55, size: 64, offset: 64)
                    !55 = !DIDerivedType(tag: DW_TAG_typedef, name: "__u64",
                      file: !53, line: 31, baseType: !56)
                    ```
                    ---
                    ## Example: BTF
                    ```
                    [8] STRUCT 'foo' size=16 vlen=2
                            'a' type_id=9 bits_offset=0
                            'b' type_id=10 bits_offset=64
                    ```
                    ---
                    ## Example: Rust code
                    ```rust
                    pub struct Foo {
                        a: u32,
                        b: u64,
                    }
                    ```
                    ---
                    ## Example: LLVM debug info
                    ```
                    !42 = !DIBasicType(name: "u32", size: 32,
                      encoding: DW_ATE_unsigned)
                    !60 = !DICompositeType(tag: DW_TAG_structure_type, name: "Foo",
                      scope: !2, file: !5, size: 128, align: 64, elements: !61,
                      templateParams: !65,
                      identifier: "63dcf8d9f7a7a7ed6f05eaed70c4b12f")
                    !61 = !{!62, !63}
                    !62 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !60,
                      file: !5, baseType: !42, size: 32, align: 32, offset: 64)
                    !63 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !60,
                      file: !5, baseType: !64, size: 64, align: 64)
                    !64 = !DIBasicType(name: "u64", size: 64,
                      encoding: DW_ATE_unsigned)
                    ```
                    ---
                    ## Example: BTF
                    ```
                    [20] STRUCT 'Foo' size=16 vlen=2
                            'a' type_id=14 bits_offset=64
                            'b' type_id=21 bits_offset=0
                    ```
                    ---
                    ## Local BTF
                    Each modern Linux kernel comes with BTF info:
                    ```
                    # bpftool btf dump file /sys/kernel/btf/vmlinux
                    [...]
                    [335] STRUCT 'pid' size=112 vlen=8
                            'count' type_id=330 bits_offset=0
                            'level' type_id=59 bits_offset=32
                            'lock' type_id=324 bits_offset=64
                            'tasks' type_id=336 bits_offset=128
                            'inodes' type_id=134 bits_offset=384
                            'wait_pidfd' type_id=328 bits_offset=448
                            'rcu' type_id=139 bits_offset=640
                            'numbers' type_id=337 bits_offset=768
                    ```
                    ---
                    ## ELF sections
                    ---
                    ## .BTF section
                    ---
                    ## .BTF.ext section
                    ---
                    ## BTF_ids section
                    ---
                    ## BTF relocations
                    * BPF programs are adjusted to read type fields at the offset
                      specified in **local** BTF info.
                    * Regardless of the memory layout of the type.
                    * Types with BTF-based access are annotated with `llvm.preserve.*.access.index`
                      intrinsics.
                    ---
                    ## Challenges with Rust
                    * BPF support introduced later than in Clang.
                    * BTF emission not supported, but close to be done!
                    * BTF relocations not supported.
                    ---
                    ## What's the problem?
                    * Kernel expects specific BTF layout.
                    * It's very C-specific.
                      * BPF maps definitions have to be anonymous structs (which
                        Rust doesn't support).
                      * Complex Rust types (e.g. data carrying enums) are not
                        supported.
                    ---
                    ## Solutions
                    * Temporary: modify DI in bpf-linker.
                    * Long-term: `#[btf_export]` macro in Rust.
                    ---
                    ## bpf-linker
                    Currently working PoC. Transforms DI to meet kernel expectations:
                    * Removes names from pointer types and BTF map structs.
                    * Tweaks the DI of Rust-specific types to be C-compatible.
                    ---
                    ## BTF (from Rust) after modifications
                    ```
                    [10] STRUCT '(anon)' size=40 vlen=5
                            'type' type_id=1 bits_offset=0
                            'key' type_id=5 bits_offset=64
                            'value' type_id=5 bits_offset=128
                            'max_entries' type_id=6 bits_offset=192
                            'map_flags' type_id=8 bits_offset=256
                    ```
                    ```
                    [6] PTR '(anon)' type_id=7
                    ```
                    ---
                    ## Debug info included
                    ```
                    ; let parent_pid: i32 = unsafe {
                        ctx.read_at(PARENT_PID_OFFSET)? };
                    9: 63 1a f4 ff 00 00 00 00 *(u32 *)(r10 - 0xc) = r1
                    [...]
                    ; let child_pid: i32 = unsafe {
                        ctx.read_at(CHILD_PID_OFFSET)? };
                    19: 63 1a f8 ff 00 00 00 00 *(u32 *)(r10 - 0x8) = r1
                    20: bf a2 00 00 00 00 00 00 r2 = r10
                    ```
                    ---
                    ## LLVM changes
                    * Already merged, but to be released in LLVM 17:
                      * `LLVMGetDINodeTag` function to get the tag of DI Node.
                      * `LLVMReplaceMDNodeOperandWith` function to modify DI.
                    ---
                    ## #[btf_export]
                    * Decoupled from `-C debuginfo`.
                    * Generates DI, which produces correct BTF for annotated 
                      types.
                    * Raises a compiler error when used on BTF-incompatible
                      type.
                    ---
                    ## If you want to try it out
                    * [github.com/vadorovsky/aya-btf-map](https://github.com/vadorovsky/aya-btf-map) -
                      structs and macros for BTF maps.
                    * [github.com/vadorovsky/aya-btf-maps-experiments](https://github.com/vadorovsky/aya-btf-maps-experiments) -
                      example project using it.
                    * Requires LLVM and bpf-linker patches.
                    ---
                    ## Demo
                    Let's write a simple LSM program which restricts filesystem
                    access!
                    ---
                    ## Thank you
                    * [aya-rs.dev](https://aya-rs.dev/)
                      * [github.com/aya-rs/aya](https://github.com/aya-rs/aya)
                      * [Discord](https://discord.gg/xHW2cb2N6G)
                    * [lightprotocol.com](https://lightprotocol.com/)
                </textarea>
      </section>
    </div>
  </div>
  <script type="module" src="/main.js"></script>
</body>

</html>