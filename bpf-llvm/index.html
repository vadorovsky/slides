<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BPF LLVM</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown>
        <textarea data-template>
                    ## The BPF target in LLVM
                    <img src="/images/ebpf.png" />
                    ---
                    ## About me
                    * Michal Rostecki
                    * **vadorovsky** @ Github, Discord, Mastodon etc.
                    * Software Engineer @ [**Light Protocol**](https://lightprotocol.com) (ZK on Solana)
                    * [**Aya**](https://aya-rs.dev) maintainer (BPF library for Rust)
                    * Interests: Linux kernel, Rust, ZK cryptography
                    ---
                    ## BPF
                    * "Berkeley Packet Filter"
                    * ...but that's not what it is, really.
                    * It's a virtual machine for running minimal, sandboxed programs.
                    * Restricted environment (instruction limit, verifier).
                    * Rules: execute fast, don't sleep*, don't allocate too much
                      memory.
                    ---
                    ## Use cases
                    * **Linux kernel** - BPF originates from there
                      * Network filtering
                      * Tracing and profiling
                      * Security policies
                      * Extending scheduler
                      * HID-BPF
                    ---
                    ## Use cases
                    * **Solana**
                      * Smart contracts
                    * [**IoT / microcontrollers**](https://ieeexplore.ieee.org/abstract/document/9293081)
                    ---
                    ## Storing data
                    * Stack memory is limited (512 bytes).
                    * Linux kernel BPF
                      * BPF maps (stored in memory)
                    * Solana BPF
                      * Accounts (stored in memory of validator nodes)
                    ---
                    ## Projects
                    * **Cilium** - Container Network Interface for Kubernetes.
                    * **Falco** - Security alert engine.
                    * Pretty much every Solana project. Orca, Mango, Audius,
                      Metaplex, Light Protocol etc.
                    * **Good stuff from Deepfence coming soon!** Security, but
                      with focus on enforcement.
                    ---
                    ## BPF and LLVM
                    * First and main compiler providing BPF support.
                    * BPF has a backend in LLVM.
                    * Supported by Clang (C) and Rust.
                    ---
                    ## Enabling BPF backend
                    ```
                    -DLLVM_TARGETS_TO_BUILD="host;BPF"
                    ```
                    e.g.
                    ```
                    CC=clang CXX=clang++ cmake -DCMAKE_BUILD_TYPE=Debug \
                      -DLLVM_PARALLEL_LINK_JOBS=1 -DLLVM_BUILD_LLVM_DYLIB=1 \
                      -DLLVM_ENABLE_LLD=1 -DLLVM_ENABLE_PROJECTS="clang" \
                      -DLLVM_TARGETS_TO_BUILD="host;BPF"
                    ```
                    ---
                    ## Linking
                    * BPF target is **not** supported by lld.
                    * Instead, BPF has its own linkers:
                      * **bpftool-link** - creted by libbpf community
                      * **bpf-linker** - for Rust, created by Aya community
                    * Only static linking.
                    ---
                    ## lld
                    * There is a patch for lld to support BPF target, but it's
                      not accepted.
                      * https://reviews.llvm.org/D101336
                    ---
                    ## Registers
                    * **R0** - return value from functions, exit values for programs.
                    * **R1** - **R5** - function arguments.
                    * **R6** - **R9** - callee saved registers that function calls will preserve.
                    * **R10** - read-only frame pointer to access stack.
                    **R0** - **R5**: scratch registers, programs need to spill them if necessary
                    across calls.
                    ---
                    ## Basic instruction encoding
                    | 32 bits (MSB) | 16 bits | 4 bits | 4 bits | 8 bits (LSB) |
                    | --- | --- | --- | --- | --- |
                    | Integer Immediate Value | Offset | Source register | Destination register | Opcode |
                    ---
                    ## Wide instruction encoding
                    | 64 bits (MSB) | 64 bits (LSB) |
                    | --- | --- |
                    | basic instruction | pseudo instruction |
                    ---
                    ## Arithmetic instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_ADD** | dst += src |
                    | **BPF_SUB** | dst -= src |
                    | **BPF_MUL** | dst *= src |
                    | **BPF_DIV** | dst = (src != 0) ? (dst / src) : 0 |
                    | **BPF_OR** | dst |= src |
                    | **BPF_AND** | dst &= src |
                    ---
                    ## Arithmetic instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_LSH** | dst <<= src |
                    | **BPF_RSH** | dst >>= src |
                    | **BPF_NEG** | dst = ~src |
                    | **BPF_MOD** | dst = (src != 0) ? (dst % src) : dst |
                    | **BPF_XOR** | dst ^= src |
                    ---
                    ## Arithmetic instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_MOV** | dst = src |
                    | **BPF_ARSH** | sign extending shift right |
                    | **BPF_END** | byte swap operations |
                    ---
                    ## Byte swap instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_TO_LE** | host byte order -> little endian |
                    | **BPF_TO_BE** | host byte order -> big endian |
                    ---
                    ## Jump instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_JA** | PC += off |
                    | **BPF_JEQ** | PC += off if dst == src |
                    | **BPF_JGT** | PC += off if dst > src |
                    | **BPF_JGE** | PC += off if dst >= src |
                    ---
                    ## Jump instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_JSET** | PC += off if dst & src |
                    | **BPF_JNE** | PC += off if dst != src |
                    | **BPF_JSGT** | PC += off if dst > src |
                    | **BPF_JSGE** | PC += off if dst >= src |
                    ---
                    ## Jump instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_CALL** | function call |
                    | **BPF_EXIT** | program return |
                    ---
                    ## Jump instructions
                    | Code | Description |
                    | --- | --- |
                    | **BPF_JLT** | PC += off if dst < src |
                    | **BPF_JLE** | PC += off if dst <= src |
                    | **BPF_JSLT** | PC += off if dst < src |
                    | **BPF_JSLE** | PC += off if dst <= src |
                    ---
                    ## Atomic operations
                    | Code | Description |
                    | --- | --- |
                    | **BPF_ADD** | atomic add |
                    | **BPF_OR** | atomic or |
                    | **BPF_AND** | atomic and |
                    | **BPF_XOR** | atomic xor |
                    ---
                    ## Atomic operations
                    These atomic operations work only on 64 and 32 bit types.

                    Atomic CAS is **not** supported.
                    ---
                    ## Example (C code)
                    ```c
                    #include <linux/bpf.h>
                    #include <bpf/bpf_helpers.h>

                    SEC("xdp")
                    int  xdp_prog_simple(struct xdp_md *ctx)
                    {
                    	return XDP_PASS;
                    }

                    char _license[] SEC("license") = "GPL";
                    ```
                    ---
                    ## Building (clang)
                    ```
                    clang -O2 -target bpf -c -g xdp_pass_kern.c \
                      -o xdp_pass_kern.o
                    ```
                    ---
                    ## llvm-readelf
                    ```
                    $ llvm-readelf -S xdp_pass_kern.o
                    Section Headers:
                      [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
                      [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
                      [ 1] .strtab           STRTAB          0000000000000000 000b5a 0000e9 00      0   0  1
                      [ 2] .text             PROGBITS        0000000000000000 000040 000000 00  AX  0   0  4
                      [ 3] xdp               PROGBITS        0000000000000000 000040 000010 00  AX  0   0  8
                      [ 4] license           PROGBITS        0000000000000000 000050 000004 00  WA  0   0  1
                      [ 5] .debug_abbrev     PROGBITS        0000000000000000 000054 0000bd 00      0   0  1
                      [ 6] .debug_info       PROGBITS        0000000000000000 000111 0000cd 00      0   0  1
                      [ 7] .rel.debug_info   REL             0000000000000000 0008b8 000040 10   I 23   6  8
                      [ 8] .debug_str_offsets PROGBITS       0000000000000000 0001de 000068 00      0   0  1
                      [ 9] .rel.debug_str_offsets REL        0000000000000000 0008f8 000180 10   I 23   8  8
                      [10] .debug_str        PROGBITS        0000000000000000 000246 000187 01  MS  0   0  1
                      [11] .debug_addr       PROGBITS        0000000000000000 0003cd 000018 00      0   0  1
                      [12] .rel.debug_addr   REL             0000000000000000 000a78 000020 10   I 23  11  8
                      [13] .BTF              PROGBITS        0000000000000000 0003e8 000222 00      0   0  4
                      [14] .rel.BTF          REL             0000000000000000 000a98 000010 10   I 23  13  8
                      [15] .BTF.ext          PROGBITS        0000000000000000 00060c 000050 00      0   0  4
                      [16] .rel.BTF.ext      REL             0000000000000000 000aa8 000020 10   I 23  15  8
                      [17] .debug_frame      PROGBITS        0000000000000000 000660 000028 00      0   0  8
                      [18] .rel.debug_frame  REL             0000000000000000 000ac8 000020 10   I 23  17  8
                      [19] .debug_line       PROGBITS        0000000000000000 000688 00008c 00      0   0  1
                      [20] .rel.debug_line   REL             0000000000000000 000ae8 000070 10   I 23  19  8
                      [21] .debug_line_str   PROGBITS        0000000000000000 000714 000082 01  MS  0   0  1
                      [22] .llvm_addrsig     LLVM_ADDRSIG    0000000000000000 000b58 000002 00   E 23   0  1
                      [23] .symtab           SYMTAB          0000000000000000 000798 000120 18      1  10  8
                    ```
                    ---
                    ## llvm-objdump
                    ```
                    $ llvm-objdump -S xdp_pass_kern.o

                    xdp_pass_kern.o:        file format elf64-bpf
                                      
                    Disassembly of section xdp:
                                      
                    0000000000000000 <xdp_prog_simple>:
                    ;       return XDP_PASS;
                           0:       b7 00 00 00 02 00 00 00 r0 = 0x2
                           1:       95 00 00 00 00 00 00 00 exit
                    ```
                    ---
                    ## Emitting IR
                    ```
                    clang -O2 -target bpf -c -g xdp.c -S -emit-llvm -o xdp.ll
                    ```
                    ---
                    ## IR
                    ```
                    define dso_local i32 @xdp_prog_simple(ptr nocapture readnone
                      %ctx) #0 section "xdp" !dbg !24 {
                    entry:
                      call void @llvm.dbg.value(metadata ptr poison, metadata !40,
                        metadata !DIExpression()), !dbg !41
                      ret i32 2, !dbg !42
                    }
                    ```
                    ---
                    ## Example (Rust code)
                    ```rust
                    #![no_std]
                    #![no_main]
                                      
                    use aya_bpf::{bindings::xdp_action, cty::c_long, macros::xdp, programs::XdpContext};

                    #[xdp(name = "xdp")]
                    pub fn xdp(ctx: XdpContext) -> u32 {
                        match try_xdp_hello(ctx) {
                            Ok(ret) => ret,
                            Err(_) => xdp_action::XDP_ABORTED,
                        }
                    }

                    fn try_xdp_hello(_ctx: XdpContext) -> Result<u32, c_long> {
                        Ok(xdp_action::XDP_PASS)
                    }
                    ```
                    ---
                    ## Building (Rust)
                    ```
                    cargo +nightly build --target=bpfel-unknown-none \
                      -Z build-std=core
                    ```
                    ---
                    ## llvm-readelf
                    ```
                    $ llvm-readelf -S target/bpfel-unknown-none/debug/xdp
                    There are 5 section headers, starting at offset 0x220:

                    Section Headers:
                      [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
                      [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
                      [ 1] .strtab           STRTAB          0000000000000000 0001c0 00005e 00      0   0  1
                      [ 2] .text             PROGBITS        0000000000000000 000040 000098 00  AX  0   0  8
                      [ 3] xdp/xdp           PROGBITS        0000000000000000 0000d8 000010 00  AX  0   0  8
                      [ 4] .symtab           SYMTAB          0000000000000000 0000e8 0000d8 18      1   6  8
                    ```
                    ---
                    ## llvm-objdump
                    ```
                    $ llvm-objdump -S target/bpfel-unknown-none/debug/xdp-hello
                    [...]
                    Disassembly of section xdp/xdp:

                    0000000000000000 <xdp>:
                           0:       b7 00 00 00 02 00 00 00 r0 = 0x2
                           1:       95 00 00 00 00 00 00 00 exi
                    ```
                    ---
                    ## Emitting IR
                    ```
                    cargo +nightly rustc --target=bpfel-unknown-none \
                      -Z build-std=core -- --emit=llvm-ir
                    ```
                    ---
                    ## IR
                    ```
                    define dso_local noundef i32 @xdp(ptr nocapture noundef
                      readnone %ctx) unnamed_addr #0 section "xdp/xdp" {
                    start:
                      ret i32 2
                    }
                    ```
                    ---
                    ## BPF Type Format (BTF)
                    * Debug info format for BPF, way more lightweight than DWARF.
                    * Used for offsets across Linux kernel versions.
                    * Used for stack traces in BPF verifier.
                    * But there is no debugger (yet).
                    ---
                    ## Example: C code
                    ```c
                    struct foo {
                    	__u32 a;
                    	__u64 b;
                    };
                    ```
                    ---
                    ## Example: LLVM debug info
                    ```
                    !49 = distinct !DICompositeType(tag: DW_TAG_structure_type,
                      name: "foo", file: !3, line: 21, size: 128, elements: !50)
                    !50 = !{!51, !54}
                    !51 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !49,
                      file: !3, line: 22, baseType: !52, size: 32)
                    !52 = !DIDerivedType(tag: DW_TAG_typedef, name: "__u32",
                      file: !53, line: 27, baseType: !12)
                    !54 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !49,
                      file: !3, line: 23, baseType: !55, size: 64, offset: 64)
                    !55 = !DIDerivedType(tag: DW_TAG_typedef, name: "__u64",
                      file: !53, line: 31, baseType: !56)
                    ```
                    ---
                    ## Example: BTF
                    ```
                    [8] STRUCT 'foo' size=16 vlen=2
                            'a' type_id=9 bits_offset=0
                            'b' type_id=10 bits_offset=64
                    ```
                    ---
                    ## Example: Rust code
                    ```rust
                    pub struct Foo {
                        a: u32,
                        b: u64,
                    }
                    ```
                    ---
                    ## Example: LLVM debug info
                    ```
                    !42 = !DIBasicType(name: "u32", size: 32,
                      encoding: DW_ATE_unsigned)
                    !60 = !DICompositeType(tag: DW_TAG_structure_type, name: "Foo",
                      scope: !2, file: !5, size: 128, align: 64, elements: !61,
                      templateParams: !65,
                      identifier: "63dcf8d9f7a7a7ed6f05eaed70c4b12f")
                    !61 = !{!62, !63}
                    !62 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !60,
                      file: !5, baseType: !42, size: 32, align: 32, offset: 64)
                    !63 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !60,
                      file: !5, baseType: !64, size: 64, align: 64)
                    !64 = !DIBasicType(name: "u64", size: 64,
                      encoding: DW_ATE_unsigned)
                    ```
                    ---
                    ## Example: BTF
                    ```
                    [20] STRUCT 'Foo' size=16 vlen=2
                            'a' type_id=14 bits_offset=64
                            'b' type_id=21 bits_offset=0
                    ```
                    ---
                    ## Local BTF
                    Each modern Linux kernel comes with BTF info:
                    ```
                    # bpftool btf dump file /sys/kernel/btf/vmlinux
                    [...]
                    [335] STRUCT 'pid' size=112 vlen=8
                            'count' type_id=330 bits_offset=0
                            'level' type_id=59 bits_offset=32
                            'lock' type_id=324 bits_offset=64
                            'tasks' type_id=336 bits_offset=128
                            'inodes' type_id=134 bits_offset=384
                            'wait_pidfd' type_id=328 bits_offset=448
                            'rcu' type_id=139 bits_offset=640
                            'numbers' type_id=337 bits_offset=768
                    ```
                    ---
                    ## BTF relocations
                    * BPF programs are adjusted to read type fields at the offset
                      specified in **local** BTF info.
                    * Regardless of the memory layout of the type.
                    * Types with BTF-based access are annotated with `llvm.preserve.*.access.index`
                      intrinsics.
                    ---
                    ## Challenges with Rust
                    * BPF support introduced later than in Clang.
                    * BTF emission not supported, but close to be done!
                    * BTF relocations not supported.
                    ---
                    ## What's the problem?
                    * Kernel expects specific BTF layout.
                    * It's very C-specific.
                      * BPF maps definitions have to be anonymous structs (which
                        Rust doesn't support).
                      * Complex Rust types (e.g. data carrying enums) are not
                        supported.
                    ---
                    ## Solutions
                    * Temporary: modify DI in bpf-linker.
                    * Long-term: `#[btf_export]` macro in Rust.
                    ---
                    ## bpf-linker
                    Currently working PoC. Transforms DI to meet kernel expectations:
                    * Removes names from pointer types and BTF map structs.
                    * Tweaks the DI of Rust-specific types to be C-compatible.
                    ---
                    ## BTF (from Rust) after modifications
                    ```
                    [10] STRUCT '(anon)' size=40 vlen=5
                            'type' type_id=1 bits_offset=0
                            'key' type_id=5 bits_offset=64
                            'value' type_id=5 bits_offset=128
                            'max_entries' type_id=6 bits_offset=192
                            'map_flags' type_id=8 bits_offset=256
                    ```
                    ```
                    [6] PTR '(anon)' type_id=7
                    ```
                    ---
                    ## Debug info included
                    ```
                    ; let parent_pid: i32 = unsafe {
                        ctx.read_at(PARENT_PID_OFFSET)? };
                    9: 63 1a f4 ff 00 00 00 00 *(u32 *)(r10 - 0xc) = r1
                    [...]
                    ; let child_pid: i32 = unsafe {
                        ctx.read_at(CHILD_PID_OFFSET)? };
                    19: 63 1a f8 ff 00 00 00 00 *(u32 *)(r10 - 0x8) = r1
                    20: bf a2 00 00 00 00 00 00 r2 = r10
                    ```
                    ---
                    ## LLVM changes
                    * Already merged, but to be released in LLVM 17:
                      * `LLVMGetDINodeTag` function to get the tag of DI Node.
                      * `LLVMReplaceMDNodeOperandWith` function to modify DI.
                    ---
                    ## If you want to try it out
                    * [github.com/vadorovsky/aya-btf-map](https://github.com/vadorovsky/aya-btf-map) -
                      structs and macros for BTF maps.
                    * [github.com/vadorovsky/aya-btf-maps-experiments](https://github.com/vadorovsky/aya-btf-maps-experiments) -
                      example project using it.
                    * Requires LLVM and bpf-linker patches.
                    ---
                    ## #[btf_export]
                    * Decoupled from `-C debuginfo`.
                    * Generates DI, which produces correct BTF for annotated 
                      types.
                    * Raises a compiler error when used on BTF-incompatible
                      type.
                    ---
                    ## Verifier
                    * (So far) only in Linux kernel (Solana, rBPF and other user space
                      implementations don't have it).
                    * Ensuring safe memory access - kinda, like, making C Rusty ( ͡° ͜ʖ ͡°).
                    * Descending all possible instruction paths, observing the
                      change of registers and stack.
                    ---
                    ## Register state types
                    * `NOT_INIT` - was never written to.
                    * `SCALAR_VALUE` - value not usable as a pointer.
                    * `PTR_TO_CTX` - program context.
                    * `CONST_PTR_TO_MAP` - pointer to BPF map.
                    * `PTR_TO_MAP_VALUE` - pointer to BPF map value.
                    * `PTR_TO_MAP_VALUE_OR_NULL` - pointer to BPF map value or NULL.
                    * `PTR_TO_STACK` - frame pointer.
                    ---
                    ## Register state types
                    * `PTR_TO_PACKET` - pointer to network packet data.
                    * `PTR_TO_PACKET_END` - pointer to end of network packet data.
                    * `PTR_TO_SOCKET` - pointer to `bpf_sock_ops`.
                    * `PTR_TO_SOCKET_OR_NULL` - pointer to `bpf_sock_ops` or NULL.
                    ---
                    ## What doesn't pass verifier
                    * Reading from registers which were never written to.
                    * Instructions which are unreachable.
                    * Loops without bounds (to a constant).
                    * Memory access without bounds (to a constant).
                    * Direct packet access outside the end of packet.
                    ---
                    ## Demo
                    Let's write a simple LSM program which restricts filesystem
                    access!
                    ---
                    ## Thank you
                    * [aya-rs.dev](https://aya-rs.dev/)
                      * [github.com/aya-rs/aya](https://github.com/aya-rs/aya)
                      * [Discord](https://discord.gg/xHW2cb2N6G)
                    * [lightprotocol.com](https://lightprotocol.com/)
                </textarea>
      </section>
    </div>
  </div>
  <script type="module" src="/main.js"></script>
</body>

</html>