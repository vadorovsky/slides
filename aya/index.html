<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aya</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown>
        <textarea data-template>
          ## Aya
          Easy development of eBPF programs in Rust.
          <img src="/images/crabby.svg" width="400" height="400" />
          ---
          ## About me
          * Michal Rostecki
          * vadorovsky @ Github, Discord, Matrix etc.
          * Software Engineer @ Deepfence Inc
          * Rustacean with Go, C and Python background
          ---
          ## What is eBPF?
          TECHNOLOGY OF THE FUTURE WHICH WILL REPLACE IPTABLES ANY DAY
          <br />
          <img src="/images/girl_explaining.jpg" height="400" />
          ---
          ## What is eBPF?
          * **extended Berkeley Packet Filter**
          * A virtual machine with its own instruction set which runs sandboxed programs.
          * Not Turing complete.
          * Originated in the Linux kernel.
          ---
          ## Event-driven
          * Triggered by events in the kernel.
          * Receiving pointers to kernel or userspace memory.
          ---
          ## What events?
          ---
          ## Network traffic
          * **XDP** - ingress trafic on NIC driver
          * **Classifier** - both directions, attached to qdisc
          ---
          ## Function calls
          * **Kprobes** - kernel functions
          * **Uprobes** - userspace functions
          ---
          ## Security-related actions
          * **LSM** hooks
          ---
          ## And many many more...
          ---
          <img src="/images/ebpf.png" height="600" />
          ---
          ## BPF maps
          * Storage for sharing data between eBPF programs (in kernel) and userspace.
          * Different types:
            * hash maps
            * arrays
            * perf buffers
          ---
          <img src="/images/bpf_map.png" height="400" />
          ---
          ## Examples of eBPF projects
          * **Cilium** - Kubernetes networking, service mesh
          * **Tracee** - application tracing tool
          * **Falco** - security monitoring for containers
          (those are in Go in C)
          ---
          ## Examples of eBPF projects using Aya
          * **bpfd** - daemon managing eBPF programs
          * **Parca** - continuous profiling
          * **Pulsar** - runtime observability tool for IoT
          ---
          ## eBPF project layout
          * **userspace program**: loading eBPF programs to the kernel
          * **eBPF programs**: running in the kernel and reacting to events
          ---
          ## "Official" ways to use eBPF
          * **bpftrace**: very easy, own scripting language
          * **libbpf**: umm... not easy at all (everything in C)
          * **libbpf-rs**: easier (eBPF programs in C, userspace program in Rust)
          * **bcc**: easier (eBPF programs in C, userspace in many languages)
          ---
          ## Why Aya?
          ---
          ## C and type safety
          ```c
          SEC("xdp")
          int incorrect_xdp(struct __sk_buff *skb) {
              return XDP_PASS;
          }
          ```
          We made a mistake! We should have used
          ```
          struct xdp_md *ctx
          ```
          instead of
          ```
          struct __sk_buff *skb
          ```
          ---
          ```bash
          $ clang -O2 -emit-llvm -c incorrect_xdp.c -o - | llc -march=bpf -filetype=obj -o bpf.o
          $
          ```
          But it compiles anyway, huh.
          ---
          ## Rust and type safety
          ```rust
          #[xdp(name = "incorrect_xdp")]
          pub fn incorrect_xdp(ctx: SkBuffContext) -> u32 {
              xdp_action::XDP_PASS
          }
          ```
          ---
          ```
          $ cargo xtask build-ebpf
          [...]
          error[E0308]: mismatched types
           --> src/main.rs:7:1
            |
          7 | #[xdp(name = "incorrect_xdp")]
            | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `SkBuffContext`, found struct `XdpContext`
          8 | pub fn incorrect_xdp(ctx: SkBuffContext) -> u32 {
          [...]
          ```
          It does not compile, nice.
          ---
          ## Memory safety?
          * Actually... Rust memory model doesn't matter that much in eBPF part.
          * eBPF has access to kernel and userspace memory via pointers, which are unsafe.
          * Memory safety relies more on the eBPF verifier in the kernel rather than Rust compiler.
          ---
          ## Error handling in C
          ```c
          struct {
          	__uint(type, BPF_MAP_TYPE_HASH);
          	__uint(max_entries, 1024);
          	__type(key, pid_t);
          	__type(value, u32);
          } pids SEC(".maps");
          ```

          ```c
          SEC("fentry/kernel_clone")
          int BPF_PROG(kernel_clone, struct kernel_clone_args *args)
          {
          	/* Get the pid */
          	pid_t pid = bpf_get_current_pid_tgid() >> 32;
          	/* Save the pid in map */
          	u32 val = 0;
          	int err = bpf_map_update_elem(&pids, &pid, &val, 0);
          	if (err < 0)
          		return err;
          	return 0;
          }
          ```
          ---
          ## Error handling in Rust
          ```rust
          #[map(name = "pids")]
          static mut PIDS: HashMap<u32, u32> = HashMap::<u32, u32>::with_max_entries(1024, 0);
          ```

          ```rust
          #[fentry(name = "kernel_clone")]
          pub fn kernel_clone(ctx: FEntryContext) -> u32 {
              match unsafe { try_kernel_clone(ctx) } {
                  Ok(ret) => ret,
                  Err(_) => 1,
              }
          }

          fn try_kernel_clone(ctx: FEntryContext) -> Result<u32, c_long> {
              // Get the pid
              let pid = ctx.pid();
              // Save the pid in map.
              unsafe { PIDS.insert(&pid, &0, 0)? };
              Ok(0)
          }
          ```
          ---
          ## Rust toolchain is all you need
          * No need for LLVM and clang installation...
          * ...as long as you're on x86_64
          ---
          ## aya-log
          Logging library, based on perf buffers, production-ready.

          ```rust
          #[fentry(name = "kernel_clone")]
          pub fn kernel_clone(ctx: FEntryContext) -> u32 {
              let pid = ctx.pid();
              info!(&ctx, "new process: pid: {}", pid);
              0
          }
          ```
          ---
          <img src="/images/aya-log.png" />
          ---
          ## Async support
          * Userspace part of projects can be asynchronous.
          * Support for Tokio and async-std.
          * aya-template by default uses Tokio.
          ---
          ## How to start with Aya?
          ```bash
          rustup toolchain install nightly --component rust-src
          cargo install bpf-linker
          cargo install cargo-generate
          ```
          ---
          ## aya-template
          Creating a new project:
          ```bash
          cargo install cargo-generate
          cargo generate https://github.com/aya-rs/aya-template
          ```
          ---
          <img src="/images/cargo-generate-asks-questions.png" height="400" />
          ---
          ## Project layout
          <img src="/images/project-layout.png" height="400" />
          ---
          ## Running the project
          ```bash
          cargo xtask run
          ```
          Only building:
          ```bash
          cargo xtask build-ebpf
          cargo build
          ```
          ---
          ## Let's write a simple firewall!
          ---
          ## Thank you
          * [Documentation](https://aya-rs.github.io/book/)
          * [Github](https://github.com/aya-rs/aya)
          * [Discord](https://discord.gg/xHW2cb2N6G)
        </textarea>
      </section>
    </div>
  </div>
  <script type="module" src="/main.js"></script>
</body>

</html>